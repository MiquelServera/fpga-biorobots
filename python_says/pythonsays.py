# -*- coding: utf-8 -*-

'''

Python says

A program that generates Verilog code and verify, build and load the code using APIO

Made by Juli√°n Caro Linares

jcarolinares@gmail.com

CC-BY-SA

'''

#Python 3

#Libraries
import os
import subprocess
import time

#Template generator library -Empy
import em

#Oscillator rom generator library
# from oscillator_rom_generator import all
import oscillator_rom_generator as rom_generator

#Variables
path="." #By the time the path it must be the root of the project. Apio needs that (Scons().verify doesn't have a path parameter)
fpgaboard="icezum"
pythonsays_memo="[PYTHON SAYS]: " #Keyword that defines the outputs generated by pythonsays


class VerilogBlock:
    #Parent class to create any verilog block or component
    template_name="" #You can add the partial or total route of the file
    output_file="output.v"
    argv=""

    def __init__ (self,template_name,argv,output_file):
        self.template_name=template_name
        self.argv=argv
        self.output_file=output_file

    def generate(self):
        file = open(self.output_file, 'w')
        interpreter = em.Interpreter(output=file ,argv=str(self.argv))

        # Process an actual file (and output to stdout):
        interpreter.file(open(self.template_name))
        interpreter.shutdown() # this is important; see below

    #Apio implementation using subprocess commands
    def verify(self):
        subprocess.call('apio "verify"' ,shell=True)
    def build(self):
        subprocess.call('apio "build"' ,shell=True)
    def upload(self):
        subprocess.call('apio "upload"' ,shell=True)

class CounterBlock (VerilogBlock): #The VerilogBLock is a generic class that can create whatever you want, not need of derives functions, in this case a derived function should be useful to create some very commonly used blocks inside a robot, but not 100% neccessary
    N=20

    def __init__ (self,template_name,N):
        self.N=N
        super().__init__(template_name)


#Main execution
def main():

    #test_counter=VerilogBlock("counter.em",20,"counter.v")

    #rom_generator.create_rom("sin",32,"test.list",) #Needed a rewrite of the code to simplify everthing

    test_doodle=VerilogBlock("./templates/doodle_line_follower.em","200000, \"./romlists/romlistr.list\"","doodle_line_follower.v")

    m_list=[800000,400000,200000,100000,50000,25000]

    test_doodle.generate()
    test_doodle.verify()
    test_doodle.build()
    test_doodle.upload()

    '''
    for m in m_list:
        test_doodle.argv=m

        test_doodle.generate()
        test_doodle.verify()
        test_doodle.build()
        test_doodle.upload()

        time.sleep(20)
    '''
    '''
    file_name="counter.v"

    file = open(file_name, 'w')

    m_list=[5,10,15,20,25,30]
    for m in m_list:
        print("Creando circuito con M: ",m)
        file = open(file_name, 'w')
        interpreter = em.Interpreter(output=file ,argv=str(m))

        # Process an actual file (and output to stdout):
        interpreter.file(open('counter.em'))
        interpreter.shutdown() # this is important; see below

        subprocess.call('apio "verify"' ,shell=True)
        subprocess.call('apio "build"' ,shell=True)
        subprocess.call('apio "upload"' ,shell=True)

        time.sleep(10);
        '''
if __name__ == "__main__":
 main()
