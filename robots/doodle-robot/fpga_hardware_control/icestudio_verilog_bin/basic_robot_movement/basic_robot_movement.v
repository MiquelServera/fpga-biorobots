// Code generated by Icestudio 0.3.1-rc
// Tue, 31 Oct 2017 11:35:50 GMT

`default_nettype none

module main #(
 parameter v77874e = 75,
 parameter v8a0d75 = 120,
 parameter vd6e0a6 = 63,
 parameter vbfa150 = 200,
 parameter v5e4ec8 = 100,
 parameter v48f44c = 171
) (
 input vclk,
 output v319115,
 output v4013e7,
 output v8357d7,
 output v7d17e5,
 output v76e8fc,
 output [0:5] vinit
);
 localparam p5 = vbfa150;
 localparam p6 = v77874e;
 localparam p9 = v48f44c;
 localparam p10 = vd6e0a6;
 localparam p13 = v5e4ec8;
 localparam p14 = v8a0d75;
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w7;
 wire w8;
 wire w11;
 wire w12;
 wire w15;
 wire w16;
 wire w17;
 wire w18;
 wire w19;
 assign v76e8fc = w0;
 assign v7d17e5 = w2;
 assign v319115 = w4;
 assign v4013e7 = w8;
 assign v8357d7 = w12;
 assign w16 = vclk;
 assign w17 = vclk;
 assign w18 = vclk;
 assign w19 = vclk;
 assign w1 = w0;
 assign w7 = w0;
 assign w7 = w1;
 assign w11 = w0;
 assign w11 = w1;
 assign w11 = w7;
 assign w15 = w0;
 assign w15 = w1;
 assign w15 = w7;
 assign w15 = w11;
 assign w17 = w16;
 assign w18 = w16;
 assign w18 = w17;
 assign w19 = w16;
 assign w19 = w17;
 assign w19 = w18;
 v7c0ae7 v662099 (
  .v2efea4(w3),
  .v0daa9e(w16)
 );
 v100245 v1202cd (
  .v6cebb8(w0),
  .vf45266(w3)
 );
 v32200d vd45f2a (
  .v0e28cb(w1),
  .vcbab45(w2)
 );
 va9f90b #(
  .v65ff05(p5),
  .v79a04d(p6)
 ) v67a8e6 (
  .v8aec2f(w4),
  .ve40401(w7),
  .v8c732a(w17)
 );
 va9f90b #(
  .v65ff05(p9),
  .v79a04d(p10)
 ) vb5cc60 (
  .v8aec2f(w8),
  .ve40401(w11),
  .v8c732a(w18)
 );
 va9f90b #(
  .v65ff05(p13),
  .v79a04d(p14)
 ) v89a767 (
  .v8aec2f(w12),
  .ve40401(w15),
  .v8c732a(w19)
 );
 assign vinit = 6'b000000;
endmodule

module v7c0ae7 (
 input v0daa9e,
 output v2efea4
);
 wire w0;
 wire w1;
 assign v2efea4 = w0;
 assign w1 = v0daa9e;
 v7c0ae7_v0bf905 v0bf905 (
  .clk_1hz(w0),
  .clk(w1)
 );
endmodule

module v7c0ae7_v0bf905 (
 input clk,
 output clk_1hz
);
 //-- module bomba_x1(input wire clk, output wire clk_1hz)
 
 //-- Bombeo de bits a 1Hz (1 pulsacion por segundo)
 
 //-- Constante para dividir y obtener una frecuencia de 2Hz
 localparam M = 6000000;
 
 //-- Calcular el numero de bits para almacenar M
 localparam N = $clog2(M);
 
 //-- Registro del divisor
 reg [N-1:0] divcounter;
 
 //-- Contador modulo M. tras M pulsos de relog vuelve a 0
 always @(posedge clk)
   divcounter <= (divcounter == M - 1) ? 0 : divcounter + 1;
 
 //-- Obtener la señal de 2Hz. La señal no tiene ciclo del 50%
 wire clk_2hz;
 assign clk_2hz = divcounter[N-1]; 
 
 //-- Usamos un biestable T para dividir entre 2 y obtener una señal
 //-- de 1Hz y ciclo del 50%
 reg T = 0;
 always @(posedge clk_2hz)
   T <= ~T;
   
 //-- Señal de salida de 1Hz y ciclo del 50%
 assign clk_1hz = T;
   
 //endmodule
  
 
 
endmodule

module v100245 (
 input vf45266,
 output v6cebb8
);
 wire w0;
 wire w1;
 assign w0 = vf45266;
 assign v6cebb8 = w1;
 v100245_v83141e v83141e (
  .T(w0),
  .q(w1)
 );
endmodule

module v100245_v83141e (
 input T,
 output q
);
 reg _q = 0;
 
 always @(posedge T)
   _q <= ~_q;
   
 assign q = _q;
 
endmodule

module v32200d (
 input v0e28cb,
 output vcbab45
);
 wire w0;
 wire w1;
 assign w0 = v0e28cb;
 assign vcbab45 = w1;
 v32200d_vd54ca1 vd54ca1 (
  .a(w0),
  .c(w1)
 );
endmodule

module v32200d_vd54ca1 (
 input a,
 output c
);
 // NOT logic gate
 
 assign c = ~ a;
endmodule

module va9f90b #(
 parameter v79a04d = 8'h39,
 parameter v65ff05 = 8'hAB
) (
 input v8c732a,
 input ve40401,
 output v8aec2f
);
 localparam p1 = v65ff05;
 localparam p3 = v79a04d;
 wire w0;
 wire w2;
 wire w4;
 assign v8aec2f = w0;
 assign w2 = ve40401;
 assign w4 = v8c732a;
 va9f90b_v815aa1 #(
  .in_max_angle(p1),
  .in_min_angle(p3)
 ) v815aa1 (
  .servo(w0),
  .bitpos(w2),
  .clk(w4)
 );
endmodule

module va9f90b_v815aa1 #(
 parameter in_min_angle = 0,
 parameter in_max_angle = 0
) (
 input clk,
 input bitpos,
 output servo
);
 //-- ServoBit-180
 
 //-- Control de un servo Futaba 3003
 //-- con un bit. Se mueve a dos posiciones
 //-- que se corresonden con 0 / 1
 //-- El angulo total recorrido es de 180 grados
 
 //-- ENTRADAS:
 //--  clk: Señal del sistema (12Mhz)
 //--  bitpos: Bit de posicion (0 - posicion derecha, 1 - posicion izquierda)
      
 //   Bitpos 0   Bitpos 1
 //    ___          ___
 //   | o---->  <----o |
 //   |   |        |   |
 //   |___|        |___|
 
 //-- SALIDAS:
 //-- servo : Señal PWM para controlar el servo
 
 //-- Constantes para el angulo DEL servo
 localparam ANG_0   = 8'h01;
 localparam ANG_45=8'h39;
 localparam ANG_90 = 8'h5F;
 localparam ANG_135=8'hAB;
 localparam ANG_180=8'hE0;
 localparam ANG_120=8'h5F;
 
 parameter min_angle =in_min_angle;
 parameter max_angle =in_max_angle;
 
 //-- Posicion del servo cuando el
 //-- bit de entrada es 0
 //-- La corona del servo mira a la derecha
 localparam BIT0 = min_angle;
 
 //-- Posicion el servo cuando el BIT
 //-- de entrada es 1
 //-- La corona del servo mira a la izquierda
 localparam BIT1 = max_angle;
 
 
 //-- Posicion de 8 bits del servo
 reg [7:0] pos;
 
 //-- Asignar la posicion de 8 bits
 //-- segun si lo recibido es 0 ó 1
 always @(posedge clk)
   pos <= bitpos ? BIT1 : BIT0;
 
 
 //---
 //--- ServoMotor 
 
 //-- M es el valor del divisor para
 //-- obtener tics de M / 12.0 micro-segundos
 localparam M = 94; 
 localparam N = $clog2(M);
 
 //-- Contador para generar los tics
 reg [N-1:0] divcounter = 0;
 
 //-- Flag para indicar que un tic
 //-- ha ocurrido
 reg tic = 0;
 
 //-- Generacion de los tics. Cada
 //-- M ciclos del reloj se genera 1
 always @(posedge clk)
  tic <= (divcounter == M - 2);
 
 //-- Contador modulo M
 always @(posedge clk)
  if (tic)
    divcounter <= 0;
  else
    divcounter <= divcounter + 1;
 
 //-- Contador de la posicion del 
 //-- servo
 reg [10:0] angle_counter = 0;
 
 //-- A la posicion destino hay que
 //-- sumarle un offset, correspondiente
 //-- a los 0.3ms de la posicion inicial
 wire [8:0] pose = {1'b0, pos} + 9'd46;
 
 //-- Con cada tic se incrementa el
 //-- contador de angulo del servo
 always @(posedge clk)
  if (tic)
    angle_counter <= angle_counter + 1;
 
 //-- Cuando el contador es menor que el 
 //-- valor objetivo, la señal de PWM
 //-- del servo se pone 1, y 0 en 
 //-- caso contrario
 
 reg servo;
 
 always @(posedge clk) begin
  servo <= (angle_counter < {2'b00, pose});
  end
 
 
 
 
endmodule
