// Code generated by Icestudio 0.3.1-rc
// Tue, 31 Oct 2017 11:07:23 GMT

`default_nettype none

module main #(
 parameter v3d0fbf = 8'd15,
 parameter v0ae405 = 8'd10,
 parameter v6ec67c = 8'd127,
 parameter v275834 = 80_000_000,
 parameter vf6d84e = 8'h40,
 parameter v350f57 = 8'hbf,
 parameter vef23c1 = 200_000,
 parameter v77874e = 0,
 parameter vd6e0a6 = 0,
 parameter v8a0d75 = 0,
 parameter vbfa150 = 255,
 parameter v48f44c = 255,
 parameter v5e4ec8 = 255,
 parameter v6dc2ee = 110,
 parameter vaa573c = 127
) (
 input v3948cc,
 input v617b87,
 input v506401,
 input vclk,
 output v319115,
 output va69428,
 output v4013e7,
 output v8357d7,
 output v4246bc,
 output vb0088b,
 output va1c7ea,
 output [0:4] vinit
);
 localparam p1 = v275834;
 localparam p3 = vef23c1;
 localparam p4 = v5e4ec8;
 localparam p5 = v8a0d75;
 localparam p7 = v6dc2ee;
 localparam p15 = v6ec67c;
 localparam p16 = v3d0fbf;
 localparam p17 = vf6d84e;
 localparam p18 = v350f57;
 localparam p27 = v0ae405;
 localparam p38 = vbfa150;
 localparam p40 = v77874e;
 localparam p42 = vaa573c;
 localparam p44 = v48f44c;
 localparam p45 = vd6e0a6;
 localparam p48 = vaa573c;
 wire w0;
 wire w2;
 wire w6;
 wire w8;
 wire w9;
 wire w10;
 wire w11;
 wire w12;
 wire w13;
 wire w14;
 wire w19;
 wire w20;
 wire [0:7] w21;
 wire [0:7] w22;
 wire [0:7] w23;
 wire w24;
 wire w25;
 wire [0:7] w26;
 wire [0:7] w28;
 wire w29;
 wire w30;
 wire w31;
 wire w32;
 wire w33;
 wire w34;
 wire [0:7] w35;
 wire [0:7] w36;
 wire w37;
 wire [0:7] w39;
 wire w41;
 wire w43;
 wire w46;
 wire w47;
 wire [0:7] w49;
 wire w50;
 wire w51;
 wire w52;
 wire w53;
 wire w54;
 wire w55;
 wire w56;
 wire w57;
 wire w58;
 wire w59;
 wire w60;
 wire w61;
 assign v8357d7 = w6;
 assign w11 = v617b87;
 assign w13 = v506401;
 assign w19 = v3948cc;
 assign va69428 = w24;
 assign vb0088b = w29;
 assign va1c7ea = w37;
 assign v319115 = w41;
 assign v4013e7 = w46;
 assign v4246bc = w50;
 assign w54 = vclk;
 assign w55 = vclk;
 assign w56 = vclk;
 assign w57 = vclk;
 assign w58 = vclk;
 assign w59 = vclk;
 assign w60 = vclk;
 assign w61 = vclk;
 assign w9 = w8;
 assign w10 = w8;
 assign w10 = w9;
 assign w25 = w24;
 assign w29 = w12;
 assign w33 = w12;
 assign w33 = w29;
 assign w34 = w14;
 assign w37 = w14;
 assign w37 = w34;
 assign w49 = w39;
 assign w51 = w43;
 assign w52 = w47;
 assign w55 = w54;
 assign w56 = w54;
 assign w56 = w55;
 assign w57 = w54;
 assign w57 = w55;
 assign w57 = w56;
 assign w58 = w54;
 assign w58 = w55;
 assign w58 = w56;
 assign w58 = w57;
 assign w59 = w54;
 assign w59 = w55;
 assign w59 = w56;
 assign w59 = w57;
 assign w59 = w58;
 assign w60 = w54;
 assign w60 = w55;
 assign w60 = w56;
 assign w60 = w57;
 assign w60 = w58;
 assign w60 = w59;
 assign w61 = w54;
 assign w61 = w55;
 assign w61 = w56;
 assign w61 = w57;
 assign w61 = w58;
 assign w61 = w59;
 assign w61 = w60;
 v2003b1 #(
  .veca477(p3)
 ) v4d1718 (
  .v22d3e8(w20),
  .vc04c2e(w54)
 );
 v2003b1 #(
  .veca477(p1)
 ) v9b05a6 (
  .v22d3e8(w2),
  .vc04c2e(w55)
 );
 v70ff7f vc69fb4 (
  .vef4cea(w0),
  .vb55943(w2),
  .vc24d9f(w8)
 );
 v3e6c24 v02bc91 (
  .v608bd9(w0)
 );
 v589d01 #(
  .v65ff05(p4),
  .v79a04d(p5),
  .vc78345(p7)
 ) veeeca6 (
  .v8aec2f(w6),
  .v4e3a3a(w8),
  .v3984b5(w26),
  .vc27e17(w56)
 );
 v91abf1 v583dfe (
  .vcdeb69(w9),
  .v695853(w12),
  .v09a613(w43)
 );
 v91abf1 v180790 (
  .vcdeb69(w10),
  .v695853(w14),
  .v09a613(w47)
 );
 v10d933 v6a480b (
  .v6a82dd(w11),
  .vd4e5d7(w12),
  .v444878(w57)
 );
 v10d933 v225039 (
  .v6a82dd(w13),
  .vd4e5d7(w14),
  .v444878(w58)
 );
 v36d45a #(
  .vc5c8ea(p15)
 ) v481981 (
  .v7d356d(w21)
 );
 v36d45a #(
  .vc5c8ea(p16)
 ) vd6c325 (
  .v7d356d(w35)
 );
 v36d45a #(
  .vc5c8ea(p17)
 ) v047ae1 (
  .v7d356d(w22)
 );
 v36d45a #(
  .vc5c8ea(p18)
 ) vb360aa (
  .v7d356d(w23)
 );
 va1b138 vf6141c (
  .v26bbef(w19),
  .v21a20e(w20),
  .v80e965(w21),
  .v8071e6(w22),
  .v9ec8c5(w23),
  .ve29c69(w24),
  .v71e3cf(w28),
  .vcff1aa(w39)
 );
 main_v2bf00b v2bf00b (
  .c_down(w25),
  .angle(w26)
 );
 v96b879 vc72c1a (
  .vd84de7(w28),
  .v6b9589(w32),
  .v33d7dd(w35),
  .vbcbf2f(w36)
 );
 v36d45a #(
  .vc5c8ea(p27)
 ) v6d63a7 (
  .v7d356d(w36)
 );
 v0ec077 va139e4 (
  .v25ee73(w30),
  .v4b5bc2(w34)
 );
 v0ec077 v17035d (
  .v25ee73(w31),
  .v4b5bc2(w33)
 );
 v493ea8 v4af042 (
  .v0e28cb(w30),
  .v3ca442(w31),
  .vcbab45(w32)
 );
 vde73c6 #(
  .v65ff05(p38),
  .v79a04d(p40),
  .vc78345(p42)
 ) vc0881c (
  .v3984b5(w39),
  .v8aec2f(w41),
  .v4e3a3a(w43),
  .vc27e17(w59)
 );
 vde73c6 #(
  .v65ff05(p44),
  .v79a04d(p45),
  .vc78345(p48)
 ) v3a7b92 (
  .v8aec2f(w46),
  .v4e3a3a(w47),
  .v3984b5(w49),
  .vc27e17(w60)
 );
 v683fb5 v02855d (
  .vc1e078(w50),
  .v988fa6(w53),
  .v3f7650(w61)
 );
 v3dfc1e v4dd0d6 (
  .v0e28cb(w51),
  .v3ca442(w52),
  .vcbab45(w53)
 );
 assign vinit = 5'b00000;
endmodule

module v2003b1 #(
 parameter veca477 = 12_000_000
) (
 input vc04c2e,
 output v22d3e8
);
 localparam p2 = veca477;
 wire w0;
 wire w1;
 assign w0 = vc04c2e;
 assign v22d3e8 = w1;
 v2003b1_v3805f2 #(
  .M_in(p2)
 ) v3805f2 (
  .clk(w0),
  .clk_out(w1)
 );
endmodule

module v2003b1_v3805f2 #(
 parameter M_in = 0
) (
 input clk,
 output clk_out
);
 //-- module bomba_x1(input wire clk, output wire clk_1hz)
 
 //-- Bombeo de bits de periodo regular a X Hz (Dictado por M y N)
 
 //-- Constante para dividir y obtener una frecuencia de  X Hz
 parameter M = M_in;
 
 //-- Calcular el numero de bits para almacenar M
 localparam N = $clog2(M);
 
 //-- Registro del divisor
 reg [N-1:0] divcounter;
 
 //-- Contador modulo M. tras M pulsos de reloj vuelve a 0
 always @(posedge clk)
   divcounter <= (divcounter == M - 1) ? 0 : divcounter + 1;
 
 //-- Obtener la señal de X Hz. La señal no tiene ciclo del 50%
 wire clk_doublehz;
 assign clk_doublehz = divcounter[N-1]; 
 
 //-- Usamos un biestable T para dividir entre 2 y obtener una señal
 //-- de X Hz y ciclo del 50%
 reg T = 0;
 always @(posedge clk_doublehz)
   T <= ~T;
   
 //-- Señal de salida de 1Hz y ciclo del 50%
 assign clk_out = T;
   
 //endmodule
endmodule

module v70ff7f (
 input vb55943,
 input vef4cea,
 output vc24d9f
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = vef4cea;
 assign w1 = vb55943;
 assign vc24d9f = w2;
 v70ff7f_v526aa2 v526aa2 (
  .d(w0),
  .clk(w1),
  .q(w2)
 );
endmodule

module v70ff7f_v526aa2 (
 input clk,
 input d,
 output q
);
 // D flip-flop
 
 reg q = 1'b0;
 
 always @(posedge clk)
 begin
   q <= d;
 end
 
 
endmodule

module v3e6c24 (
 output v608bd9
);
 wire w0;
 assign v608bd9 = w0;
 v3e6c24_v68c173 v68c173 (
  .v(w0)
 );
endmodule

module v3e6c24_v68c173 (
 output v
);
 // Bit 1
 
 assign v = 1'b1;
endmodule

module v589d01 #(
 parameter v79a04d = 8'h00,
 parameter v65ff05 = 8'hFF,
 parameter vc78345 = 8'h7F
) (
 input vc27e17,
 input [0:7] v3984b5,
 input v4e3a3a,
 output v8aec2f
);
 localparam p1 = v65ff05;
 localparam p2 = v79a04d;
 localparam p3 = vc78345;
 wire w0;
 wire w4;
 wire w5;
 wire [0:7] w6;
 assign v8aec2f = w0;
 assign w4 = vc27e17;
 assign w5 = v4e3a3a;
 assign w6 = v3984b5;
 v589d01_v815aa1 #(
  .in_max_angle(p1),
  .in_min_angle(p2),
  .in_home_pos(p3)
 ) v815aa1 (
  .servo(w0),
  .clk(w4),
  .enable_mov(w5),
  .bitpos(w6)
 );
endmodule

module v589d01_v815aa1 #(
 parameter in_min_angle = 0,
 parameter in_max_angle = 0,
 parameter in_home_pos = 0
) (
 input clk,
 input [7:0] bitpos,
 input enable_mov,
 output servo
);
 //-- ServoBit-180
 
 //-- Control de un servo Futaba 3003
 //-- con un bit. Se mueve a dos posiciones
 //-- Si enable movement está 0, el servo se mantiene en la posición "home_pos"
 //-- que se corresonden con 0 / 1
 //-- El angulo total recorrido es de 180 grados
 
 //-- ENTRADAS:
 //--  clk: Señal del sistema (12Mhz)
 //--  bitpos: Bit de posicion (0 - posicion derecha, 1 - posicion izquierda)
      
 //   Bitpos 0   Bitpos 1
 //    ___          ___
 //   | o---->  <----o |
 //   |   |        |   |
 //   |___|        |___|
 
 //-- SALIDAS:
 //-- servo : Señal PWM para controlar el servo
 
 //-- Constantes para el angulo DEL servo
 localparam ANG_0   = 8'h01;
 localparam ANG_45=8'h39;
 localparam ANG_90 = 8'h5F;
 localparam ANG_135=8'hAB;
 localparam ANG_180=8'hE0;
 localparam ANG_120=8'h5F;
 
 parameter min_angle =in_min_angle;
 parameter max_angle =in_max_angle;
 parameter home_pos=in_home_pos;
 
 //-- Posicion del servo cuando el
 //-- bit de entrada es 0
 //-- La corona del servo mira a la derecha
 localparam BIT0 = min_angle;
 
 //-- Posicion el servo cuando el BIT
 //-- de entrada es 1
 //-- La corona del servo mira a la izquierda
 localparam BIT1 = max_angle;
 
 //--Posicion del servo neutra o home
 localparam BITH=home_pos;
 
 
 //-- Posicion de 8 bits del servo
 reg [7:0] pos;
 
 //-- Asignar la posicion de 8 bits
 //-- segun si lo recibido es 0 ó 1 o segun si el enable_mov está activado
 always @(posedge clk)
     begin
     if (enable_mov ==0)
         begin
            pos<=BITH;
         end   
     else if (bitpos>BIT1)
         begin
            pos<=BIT1;
         end
     else if (bitpos<BIT0)
         begin
            pos<=BIT0;
         end
     else
         begin
            pos<=bitpos;
         end
     end
 
 
 //always @(posedge clk)
 //  begin//pos <= bitpos ? BIT1 : BIT0;
 //    if (enable_mov ==0)
 //       pos<=BITH;
 //    else if (bitpos==0)
 //       pos<=BIT0;
 //    else
 //       pos<=BIT1;
 //  end  
   
 //---
 //--- ServoMotor 
 
 //-- M es el valor del divisor para
 //-- obtener tics de M / 12.0 micro-segundos
 localparam M = 94; 
 localparam N = $clog2(M);
 
 //-- Contador para generar los tics
 reg [N-1:0] divcounter = 0;
 
 //-- Flag para indicar que un tic
 //-- ha ocurrido
 reg tic = 0;
 
 //-- Generacion de los tics. Cada
 //-- M ciclos del reloj se genera 1
 always @(posedge clk)
  tic <= (divcounter == M - 2);
 
 //-- Contador modulo M
 always @(posedge clk)
  if (tic)
    divcounter <= 0;
  else
    divcounter <= divcounter + 1;
 
 //-- Contador de la posicion del 
 //-- servo
 reg [10:0] angle_counter = 0;
 
 //-- A la posicion destino hay que
 //-- sumarle un offset, correspondiente
 //-- a los 0.3ms de la posicion inicial
 wire [8:0] pose = {1'b0, pos} + 9'd46;
 
 //-- Con cada tic se incrementa el
 //-- contador de angulo del servo
 always @(posedge clk)
  if (tic)
    angle_counter <= angle_counter + 1;
 
 //-- Cuando el contador es menor que el 
 //-- valor objetivo, la señal de PWM
 //-- del servo se pone 1, y 0 en 
 //-- caso contrario
 
 reg servo;
 
 always @(posedge clk) begin
  servo <= (angle_counter < {2'b00, pose});
  end
 
 
 
 
endmodule

module v91abf1 (
 input v695853,
 input vcdeb69,
 output v09a613
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 assign v09a613 = w0;
 assign w2 = v695853;
 assign w3 = vcdeb69;
 v4b9553 v3d9ac5 (
  .vcbab45(w1),
  .v0e28cb(w2),
  .v3ca442(w3)
 );
 v0ec077 vfc842e (
  .v25ee73(w0),
  .v4b5bc2(w1)
 );
endmodule

module v4b9553 (
 input v0e28cb,
 input v3ca442,
 output vcbab45
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v0e28cb;
 assign w1 = v3ca442;
 assign vcbab45 = w2;
 v4b9553_vf4938a vf4938a (
  .a(w0),
  .b(w1),
  .c(w2)
 );
 v44391c vf4114c (
 
 );
 v44391c vec8c80 (
 
 );
endmodule

module v4b9553_vf4938a (
 input a,
 input b,
 output c
);
 // NAND logic gate
 
 assign c = ~(a & b);
endmodule

module v44391c
;
 v74d69b v949c82 (
 
 );
 v74d69b ve0f5c7 (
 
 );
endmodule

module v74d69b
;
 vef9670 vdb7477 (
 
 );
 vef9670 v826842 (
 
 );
 vef9670 vdc9b55 (
 
 );
 vef9670 vea688b (
 
 );
endmodule

module vef9670
;
 v8450b0 vd09707 (
 
 );
 v8450b0 v38def6 (
 
 );
 v8450b0 v0c6e31 (
 
 );
 v8450b0 v3071e7 (
 
 );
 v8450b0 vca3873 (
 
 );
endmodule

module v8450b0
;

endmodule

module v0ec077 (
 input v4b5bc2,
 output v25ee73
);
 wire w0;
 wire w1;
 wire w2;
 assign v25ee73 = w0;
 assign w1 = v4b5bc2;
 assign w2 = v4b5bc2;
 assign w2 = w1;
 v4b9553 vdf6feb (
  .vcbab45(w0),
  .v0e28cb(w1),
  .v3ca442(w2)
 );
endmodule

module v10d933 (
 input v444878,
 input v6a82dd,
 output vd4e5d7
);
 wire w0;
 wire w1;
 wire w2;
 assign vd4e5d7 = w0;
 assign w1 = v444878;
 assign w2 = v6a82dd;
 v10d933_va7041c va7041c (
  .out(w0),
  .clk(w1),
  .in(w2)
 );
endmodule

module v10d933_va7041c (
 input clk,
 input in,
 output out
);
 //-- Debouncer Circuit
 //-- It produces a stable output when the
 //-- input signal is bouncing
 
 reg btn_prev = 0;
 reg btn_out_r = 0;
 
 reg [16:0] counter = 0;
 
 
 always @(posedge clk) begin
 
   //-- If btn_prev and btn_in are differents
   if (btn_prev ^ in == 1'b1) begin
     
       //-- Reset the counter
       counter <= 0;
       
       //-- Capture the button status
       btn_prev <= in;
   end
     
   //-- If no timeout, increase the counter
   else if (counter[16] == 1'b0)
       counter <= counter + 1;
       
   else
     //-- Set the output to the stable value
     btn_out_r <= btn_prev;
 
 end
 
 assign out = btn_out_r;
 
endmodule

module v36d45a #(
 parameter vc5c8ea = 8'h00
) (
 output [7:0] v7d356d
);
 localparam p1 = vc5c8ea;
 wire [0:7] w0;
 assign v7d356d = w0;
 v36d45a_v465065 #(
  .V(p1)
 ) v465065 (
  .k(w0)
 );
endmodule

module v36d45a_v465065 #(
 parameter V = 0
) (
 output [7:0] k
);
 assign k = V;
endmodule

module va1b138 (
 input v21a20e,
 input [7:0] v80e965,
 input v26bbef,
 input [7:0] v71e3cf,
 input [7:0] v8071e6,
 input [7:0] v9ec8c5,
 output [7:0] vcff1aa,
 output ve29c69
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire [0:7] w5;
 wire w6;
 wire w7;
 wire [0:7] w8;
 wire [0:7] w9;
 wire [0:7] w10;
 wire [0:7] w11;
 wire w12;
 assign w4 = v21a20e;
 assign w5 = v80e965;
 assign w6 = v26bbef;
 assign w7 = v21a20e;
 assign w8 = v71e3cf;
 assign w9 = v8071e6;
 assign w10 = v9ec8c5;
 assign vcff1aa = w11;
 assign ve29c69 = w12;
 assign w7 = w4;
 v493ea8 v41e751 (
  .vcbab45(w0),
  .v0e28cb(w3),
  .v3ca442(w6)
 );
 ve543ae v38a488 (
  .v74a653(w1),
  .vc6ae1f(w2),
  .vd7ce19(w4)
 );
 v725b7e vcd26cc (
  .v9fb85f(w1)
 );
 v0ec077 v161325 (
  .v4b5bc2(w2),
  .v25ee73(w3)
 );
 va1b138_vcd2561 vcd2561 (
  .reset(w0),
  .center(w5),
  .cnt(w7),
  .sum_value(w8),
  .min_v(w9),
  .max_v(w10),
  .value(w11),
  .ow(w12)
 );
endmodule

module va1b138_vcd2561 (
 input cnt,
 input [7:0] center,
 input reset,
 input [7:0] sum_value,
 input [7:0] min_v,
 input [7:0] max_v,
 output [7:0] value,
 output ow
);
 /*
 
 Oscillator Counter
 
 
 Created by Julián Caro Linares
 
 jcarolinares@gmail.co,
 */
 
 
 
 
 reg value;
 reg c_down;
 
 
 
 always @(posedge cnt)
     
     if (reset==1)
         value<=center;
     else if (value>=max_v && c_down==0)
             c_down<=1;
     else if (value<=min_v && c_down==1)
             c_down<=0;
     else
         if (c_down==0)
             value<=value+sum_value;
         else
             value<=value-sum_value;
 
 assign ow=c_down;
endmodule

module v493ea8 (
 input v0e28cb,
 input v3ca442,
 output vcbab45
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 assign w0 = v0e28cb;
 assign w1 = v3ca442;
 assign vcbab45 = w2;
 v0ec077 v1a413a (
  .v4b5bc2(w0),
  .v25ee73(w3)
 );
 v0ec077 v6168dd (
  .v4b5bc2(w1),
  .v25ee73(w4)
 );
 v4b9553 vdb792a (
  .vcbab45(w2),
  .v0e28cb(w3),
  .v3ca442(w4)
 );
endmodule

module ve543ae #(
 parameter v3c760f = 0
) (
 input vd7ce19,
 input v74a653,
 output vc6ae1f
);
 localparam p1 = v3c760f;
 wire w0;
 wire w2;
 wire w3;
 assign vc6ae1f = w0;
 assign w2 = vd7ce19;
 assign w3 = v74a653;
 v77050b #(
  .v38488b(p1)
 ) v767db1 (
  .vc24d9f(w0),
  .vb55943(w2),
  .vef4cea(w3)
 );
endmodule

module v77050b #(
 parameter v38488b = 0
) (
 input vb55943,
 input vef4cea,
 output vc24d9f
);
 localparam p3 = v38488b;
 wire w0;
 wire w1;
 wire w2;
 assign w0 = vef4cea;
 assign w1 = vb55943;
 assign vc24d9f = w2;
 v77050b_v526aa2 #(
  .DINI(p3)
 ) v526aa2 (
  .d(w0),
  .clk(w1),
  .q(w2)
 );
endmodule

module v77050b_v526aa2 #(
 parameter DINI = 0
) (
 input clk,
 input d,
 output q
);
 // D flip-flop
 // parameter DINI = 0;
 
 reg q = DINI;
 
 always @(posedge clk)
   q <= d;
   
 
 
endmodule

module v725b7e (
 output v9fb85f
);
 wire w0;
 assign v9fb85f = w0;
 v725b7e_vb2eccd vb2eccd (
  .q(w0)
 );
endmodule

module v725b7e_vb2eccd (
 output q
);
 //-- Bit constante a 1
 assign q = 1'b1;
 
 
endmodule

module v96b879 (
 input [7:0] vbcbf2f,
 input [7:0] v33d7dd,
 input v6b9589,
 output [7:0] vd84de7
);
 wire w0;
 wire [0:7] w1;
 wire [0:7] w2;
 wire [0:3] w3;
 wire [0:3] w4;
 wire w5;
 wire [0:7] w6;
 wire [0:3] w7;
 wire [0:3] w8;
 wire [0:3] w9;
 wire [0:3] w10;
 assign w0 = v6b9589;
 assign w1 = vbcbf2f;
 assign vd84de7 = w2;
 assign w5 = v6b9589;
 assign w6 = v33d7dd;
 assign w5 = w0;
 vac7f49 va86eae (
  .v6b9589(w0),
  .v0a890f(w3),
  .v9295ac(w9),
  .v8fe749(w10)
 );
 vdeb8ad v4d3ae3 (
  .v3d06d6(w1),
  .vd47139(w8),
  .va80ecf(w10)
 );
 v4856f5 v37e231 (
  .vb226fb(w2),
  .v0064b3(w3),
  .vbb1f02(w4)
 );
 vac7f49 v177a18 (
  .v0a890f(w4),
  .v6b9589(w5),
  .v9295ac(w7),
  .v8fe749(w8)
 );
 vdeb8ad v66c17f (
  .v3d06d6(w6),
  .vd47139(w7),
  .va80ecf(w9)
 );
endmodule

module vac7f49 (
 input [3:0] v8fe749,
 input [3:0] v9295ac,
 input v6b9589,
 output [3:0] v0a890f
);
 wire [0:3] w0;
 wire [0:3] w1;
 wire [0:3] w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 wire w11;
 wire w12;
 wire w13;
 wire w14;
 wire w15;
 wire w16;
 wire w17;
 wire w18;
 assign v0a890f = w0;
 assign w1 = v8fe749;
 assign w2 = v9295ac;
 assign w7 = v6b9589;
 assign w8 = v6b9589;
 assign w9 = v6b9589;
 assign w10 = v6b9589;
 assign w8 = w7;
 assign w9 = w7;
 assign w9 = w8;
 assign w10 = w7;
 assign w10 = w8;
 assign w10 = w9;
 v6ac608 v1bec58 (
  .vadf1ad(w0),
  .v9623df(w3),
  .v574e61(w4),
  .v19712c(w5),
  .ve7fe79(w6)
 );
 v1d9ca5 v082be3 (
  .v21a753(w1),
  .v679115(w12),
  .v48eacb(w14),
  .v39a44e(w16),
  .vf89854(w18)
 );
 v1d9ca5 v2dfb4e (
  .v21a753(w2),
  .v679115(w11),
  .v48eacb(w13),
  .v39a44e(w15),
  .vf89854(w17)
 );
 va27ebf v8a3f12 (
  .vdcf411(w3),
  .v02803c(w10),
  .v240f0a(w17),
  .v7e3c7c(w18)
 );
 va27ebf vdc5c10 (
  .vdcf411(w6),
  .v02803c(w9),
  .v240f0a(w15),
  .v7e3c7c(w16)
 );
 va27ebf v1724df (
  .vdcf411(w4),
  .v02803c(w8),
  .v240f0a(w13),
  .v7e3c7c(w14)
 );
 va27ebf v8fa40f (
  .vdcf411(w5),
  .v02803c(w7),
  .v240f0a(w11),
  .v7e3c7c(w12)
 );
endmodule

module v6ac608 (
 input v9623df,
 input ve7fe79,
 input v574e61,
 input v19712c,
 output [3:0] vadf1ad
);
 wire [0:3] w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 assign vadf1ad = w0;
 assign w1 = v19712c;
 assign w2 = v574e61;
 assign w3 = ve7fe79;
 assign w4 = v9623df;
 v6ac608_v89b409 v89b409 (
  .o(w0),
  .i0(w1),
  .i1(w2),
  .i2(w3),
  .i3(w4)
 );
endmodule

module v6ac608_v89b409 (
 input i3,
 input i2,
 input i1,
 input i0,
 output [3:0] o
);
 assign o = {i3,i2,i1,i0};
 
 
endmodule

module v1d9ca5 (
 input [3:0] v21a753,
 output vf89854,
 output v39a44e,
 output v48eacb,
 output v679115
);
 wire [0:3] w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 assign w0 = v21a753;
 assign v679115 = w1;
 assign v48eacb = w2;
 assign v39a44e = w3;
 assign vf89854 = w4;
 v1d9ca5_v89b409 v89b409 (
  .i(w0),
  .o0(w1),
  .o1(w2),
  .o2(w3),
  .o3(w4)
 );
endmodule

module v1d9ca5_v89b409 (
 input [3:0] i,
 output o3,
 output o2,
 output o1,
 output o0
);
 assign {o3,o2,o1,o0} = i;
 
 
endmodule

module va27ebf (
 input v7e3c7c,
 input v240f0a,
 input v02803c,
 output vdcf411
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 assign vdcf411 = w0;
 assign w3 = v240f0a;
 assign w5 = v02803c;
 assign w6 = v7e3c7c;
 assign w7 = v02803c;
 assign w7 = w5;
 v493ea8 vc43974 (
  .vcbab45(w0),
  .v0e28cb(w1),
  .v3ca442(w2)
 );
 v91abf1 v2029a7 (
  .v09a613(w1),
  .v695853(w6),
  .vcdeb69(w7)
 );
 v0ec077 vee713b (
  .v25ee73(w4),
  .v4b5bc2(w5)
 );
 v91abf1 vcee616 (
  .v09a613(w2),
  .v695853(w3),
  .vcdeb69(w4)
 );
endmodule

module vdeb8ad (
 input [7:0] v3d06d6,
 output [3:0] va80ecf,
 output [3:0] vd47139
);
 wire [0:7] w0;
 wire [0:3] w1;
 wire [0:3] w2;
 assign w0 = v3d06d6;
 assign va80ecf = w1;
 assign vd47139 = w2;
 vdeb8ad_v89b409 v89b409 (
  .i(w0),
  .o1(w1),
  .o0(w2)
 );
endmodule

module vdeb8ad_v89b409 (
 input [7:0] i,
 output [3:0] o1,
 output [3:0] o0
);
 assign {o1,o0} = i;
 
 
endmodule

module v4856f5 (
 input [3:0] v0064b3,
 input [3:0] vbb1f02,
 output [7:0] vb226fb
);
 wire [0:3] w0;
 wire [0:3] w1;
 wire [0:7] w2;
 assign w0 = v0064b3;
 assign w1 = vbb1f02;
 assign vb226fb = w2;
 v4856f5_v89b409 v89b409 (
  .i1(w0),
  .i0(w1),
  .o(w2)
 );
endmodule

module v4856f5_v89b409 (
 input [3:0] i1,
 input [3:0] i0,
 output [7:0] o
);
 assign o = {i1,i0};
 
 
endmodule

module vde73c6 #(
 parameter v79a04d = 8'h00,
 parameter v65ff05 = 8'hFF,
 parameter vc78345 = 8'h7F
) (
 input vc27e17,
 input [0:7] v3984b5,
 input v4e3a3a,
 output v8aec2f
);
 localparam p1 = v65ff05;
 localparam p2 = v79a04d;
 localparam p3 = vc78345;
 wire w0;
 wire w4;
 wire w5;
 wire [0:7] w6;
 assign v8aec2f = w0;
 assign w4 = vc27e17;
 assign w5 = v4e3a3a;
 assign w6 = v3984b5;
 vde73c6_v815aa1 #(
  .in_max_angle(p1),
  .in_min_angle(p2),
  .in_home_pos(p3)
 ) v815aa1 (
  .servo(w0),
  .clk(w4),
  .enable_mov(w5),
  .bitpos(w6)
 );
endmodule

module vde73c6_v815aa1 #(
 parameter in_min_angle = 0,
 parameter in_max_angle = 0,
 parameter in_home_pos = 0
) (
 input clk,
 input [7:0] bitpos,
 input enable_mov,
 output servo
);
 //-- ServoBit-180
 
 //-- Control de un servo Futaba 3003
 //-- con un bit. Se mueve a dos posiciones
 //-- Si enable movement está 0, el servo se mantiene en la posición "home_pos"
 //-- que se corresonden con 0 / 1
 //-- El angulo total recorrido es de 180 grados
 
 //-- ENTRADAS:
 //--  clk: Señal del sistema (12Mhz)
 //--  bitpos: Bit de posicion (0 - posicion derecha, 1 - posicion izquierda)
      
 //   Bitpos 0   Bitpos 1
 //    ___          ___
 //   | o---->  <----o |
 //   |   |        |   |
 //   |___|        |___|
 
 //-- SALIDAS:
 //-- servo : Señal PWM para controlar el servo
 
 //-- Constantes para el angulo DEL servo
 localparam ANG_0   = 8'h01;
 localparam ANG_45=8'h39;
 localparam ANG_90 = 8'h5F;
 localparam ANG_135=8'hAB;
 localparam ANG_180=8'hE0;
 localparam ANG_120=8'h5F;
 
 parameter min_angle =in_min_angle;
 parameter max_angle =in_max_angle;
 parameter home_pos=in_home_pos;
 
 //-- Posicion del servo cuando el
 //-- bit de entrada es 0
 //-- La corona del servo mira a la derecha
 localparam BIT0 = min_angle;
 
 //-- Posicion el servo cuando el BIT
 //-- de entrada es 1
 //-- La corona del servo mira a la izquierda
 localparam BIT1 = max_angle;
 
 //--Posicion del servo neutra o home
 localparam BITH=home_pos;
 
 
 //-- Posicion de 8 bits del servo
 reg [7:0] pos;
 reg [7:0] last_pos=BITH;
 
 //-- Asignar la posicion de 8 bits
 //-- segun si lo recibido es 0 ó 1 o segun si el enable_mov está activado
 always @(posedge clk)
     begin
     if (enable_mov ==0)
         begin
            pos<=last_pos;
         end   
     else if (bitpos>BIT1)
         begin
            pos<=BIT1;
         end
     else if (bitpos<BIT0)
         begin
            pos<=BIT0;
         end
     else
         begin
            pos<=bitpos;
            last_pos<=bitpos;
         end
     end
 
 
 //always @(posedge clk)
 //  begin//pos <= bitpos ? BIT1 : BIT0;
 //    if (enable_mov ==0)
 //       pos<=BITH;
 //    else if (bitpos==0)
 //       pos<=BIT0;
 //    else
 //       pos<=BIT1;
 //  end  
   
 //---
 //--- ServoMotor 
 
 //-- M es el valor del divisor para
 //-- obtener tics de M / 12.0 micro-segundos
 localparam M = 94; 
 localparam N = $clog2(M);
 
 //-- Contador para generar los tics
 reg [N-1:0] divcounter = 0;
 
 //-- Flag para indicar que un tic
 //-- ha ocurrido
 reg tic = 0;
 
 //-- Generacion de los tics. Cada
 //-- M ciclos del reloj se genera 1
 always @(posedge clk)
  tic <= (divcounter == M - 2);
 
 //-- Contador modulo M
 always @(posedge clk)
  if (tic)
    divcounter <= 0;
  else
    divcounter <= divcounter + 1;
 
 //-- Contador de la posicion del 
 //-- servo
 reg [10:0] angle_counter = 0;
 
 //-- A la posicion destino hay que
 //-- sumarle un offset, correspondiente
 //-- a los 0.3ms de la posicion inicial
 wire [8:0] pose = {1'b0, pos} + 9'd46;
 
 //-- Con cada tic se incrementa el
 //-- contador de angulo del servo
 always @(posedge clk)
  if (tic)
    angle_counter <= angle_counter + 1;
 
 //-- Cuando el contador es menor que el 
 //-- valor objetivo, la señal de PWM
 //-- del servo se pone 1, y 0 en 
 //-- caso contrario
 
 reg servo;
 
 always @(posedge clk) begin
  servo <= (angle_counter < {2'b00, pose});
  end
 
 
 
 
endmodule

module v683fb5 (
 input v3f7650,
 input v988fa6,
 output vc1e078
);
 wire w0;
 wire w1;
 wire w2;
 assign vc1e078 = w0;
 assign w1 = v988fa6;
 assign w2 = v3f7650;
 v683fb5_v2ebca2 v2ebca2 (
  .beep(w0),
  .play(w1),
  .clk(w2)
 );
endmodule

module v683fb5_v2ebca2 (
 input clk,
 input play,
 output beep
);
 reg [13:0] div = 0;
 
 always @(posedge clk)
   div <= div + 1;
   
 assign beep = div[13] & play;
 
 
endmodule

module v3dfc1e (
 input v0e28cb,
 input v3ca442,
 output vcbab45
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 assign vcbab45 = w0;
 assign w1 = v0e28cb;
 assign w2 = v3ca442;
 assign w4 = v3ca442;
 assign w8 = v0e28cb;
 assign w4 = w2;
 assign w8 = w1;
 v4b9553 vc87175 (
  .vcbab45(w0),
  .v0e28cb(w5),
  .v3ca442(w6)
 );
 v0ec077 v3ca685 (
  .v4b5bc2(w1),
  .v25ee73(w3)
 );
 v0ec077 vc544fc (
  .v4b5bc2(w2),
  .v25ee73(w7)
 );
 v4b9553 v17c8f6 (
  .v0e28cb(w3),
  .v3ca442(w4),
  .vcbab45(w5)
 );
 v4b9553 v3e587c (
  .vcbab45(w6),
  .v3ca442(w7),
  .v0e28cb(w8)
 );
endmodule

module main_v2bf00b (
 input c_down,
 output [7:0] angle
);
 reg angle;
 
 always@ (c_down)
 begin
     if (c_down==1)
         angle<=8'h77;//77touch left side
     else
         angle<=8'h65;//63touch right side
 
 end
endmodule
